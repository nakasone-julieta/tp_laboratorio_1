/*****************************
  QUE HACE ESTO??
	int numeros[7];
	int i;

	for (i=0; i<7; i++)
	{
		numeros[i]=5;
	}

	printf("%d ", numeros[i]);
***********************************/


/*/////////////////////////////////////////////
	int numero;
	char caracter;
	float decimal;

	if (utn_getInt(&numero, "\n\ningrese edad:", "fuera de rango", 0, 99, 3)==0)//se puede usar máscara para agregar el rango?
	{
		printf("\ningresaste %d", numero);
	}

	if (utn_getChar(&caracter, "\n\ningrese caracter:", "dato no válido", 'A', 'J', 3)==0)
	{
		printf("\ningresaste %c", caracter);
	}

	if (utn_getFloat(&decimal, "\n\ningrese numero flotante:", "fuera de rango", 0, 99.9, 3)==0)
	{
		printf("\ningresaste %f", decimal);
	}
////////////////////////////////////////////////////*/

//hasta acá son los cambios en 30/03




#include <stdio_ext.h>//siempre en linux
#include "utn.h"

int utn_getNumero(int *pNum,char*pTexto,char*pError, int minimo, int maximo,int reintento)//RECORDAR defino las variables y EL TIPO (y si es puntero)
{
	int retornoFuncion = -1;
	//int bufferInt;
	//dato ingresado por el usuario int bufferInt;
	for (int i= reintento; i >= 0; i --)// si la variable reinteno llega a 0, deja de iterar.
	{
		if (pNum != NULL && pTexto != NULL && pError != NULL && minimo <= maximo && reintento >= 0 )
			//la direccion de memoria a la que se apunta tiene que tener dato.
			// && mínimo no puede ser mayor a máximo && reintenos no puede ser negativo
		{
			printf ("%s", pTexto);//%s= array de caracteres
			__fpurge(stdin);
			scanf("%d", /*bufferInt*/pNum);
			if (/*bufferInt*/(*pNum)>= minimo && /*bufferInt*/(*pNum)<= maximo) //(cuando no uso bufferInt, uso el puntero de *pNum) uso (*pNum) porque me refiero al VALOR QUE GUARDA ESA DIRECC DE MEMORIA
			{
				//*pNum = bufferInt;
				retornoFuncion =0;
				break; //salgo de la iteración del DO para llegar directamente al return (en este caso)
			}
			else
			{
				printf ("%s", pError);
				reintento --; //si entra, la variable int reinteno (con su valor del main) desciende en 1
			}
		}
		else
		{
			printf ("%s", pError);
			reintento --;
		}
	}
	return retornoFuncion;
}
